# 클라우드 네이티브 애플리케이션에서 버추얼 스레드의 역할과 이점

안녕하세요. yeTi입니다.
오늘은 클라우드 네이티브 애플리케이션에서 **버추얼 스레드**의 역할과 이점을 알아보고자 합니다.

버추얼 스레드는 전통적인 스레드 모델의 한계를 극복하고, 더 높은 동시성을 제공하기 위해 고안된 경량 스레드 모델입니다. 본 포스팅은 버추얼 스레드의 개념부터 시작하여, 클라우드 네이티브 애플리케이션에서의 실제 적용 사례와 함께 그 이점 및 한계까지 종합적으로 분석할 것입니다.

## 클라우드 네이티브 애플리케이션의 특성

먼저 클라우드 네이티브 애플리케이션이 가지는 특성을 정리하여 큰 맥락에서 바라볼 수 있도록 하겠습니다. 클라우드 네이티브 애플리케이션은 처리량, 병렬성, 동시성, 효율성의 관점에서 다뤄볼 수 있습니다.

### 처리량(Throughput)

처리량은 애플리케이션이 단위 시간당 처리할 수 있는 작업의 총량을 의미합니다. 일반적으로 TPS(Transaction Per Second)로 측정됩니다. 높은 처리량은 애플리케이션의 성능을 평가하는 중요한 지표입니다.

### 병렬성(Parallelism)

병렬성은 처리량을 늘리기 위한 한 가지 방법으로, 애플리케이션을 **Scale Out**하여 컨테이너를 추가함으로써 물리적 자원의 양을 증가시키는 것을 의미합니다. 이를 통해 다중 CPU나 멀티코어 환경을 활용하여 여러 작업을 동시에 처리함으로써 전체적인 처리량을 향상시킬 수 있습니다.

### 동시성(Concurrency)

동시성은 제한된 자원을 효율적으로 사용하여 여러 작업을 동시에 관리하고 처리하는 능력을 의미합니다. 효과적인 동시성 관리는 시스템의 응답 속도와 안정성을 유지하는 데 필수적입니다. 예를 들어, 버추얼 스레드를 사용하면 단일 서버에서 여러 사용자의 요청을 효율적으로 관리할 수 있습니다.

### 효율성(Efficiency)

효율성은 클라우드 환경에서 리소스 자원을 최대한 효율적으로 사용하는 것을 의미합니다. 이는 작은 리소스 단위인 컨테이너를 활용하거나, 경량화된 스레드 모델을 도입함으로써 달성할 수 있습니다. 효율적인 자원 관리는 운영 비용 절감과 애플리케이션의 성능 향상에 기여합니다.

### 클라우드 네이티브 애플리케이션과 동시성의 중요성

클라우드 네이티브 애플리케이션은 현대 소프트웨어 개발의 중요한 패러다임으로 자리 잡고 있습니다. 이러한 애플리케이션은 클라우드 인프라의 유연성과 확장성을 최대한 활용하여, 빠르게 변화하는 비즈니스 요구사항에 효과적으로 대응할 수 있습니다. 특히, 클라우드 환경에서는 컨테이너 단위로 관리하는 것이 보편적인데 컨터이너는 일반적으로 작은 리소스를 할당하여 사용합니다.

이유는 물리적인 노드의 리소스 효율성을 높일 수 있는 방법은 idle 타임을 최대한 줄이는 것입니다. 물리적인 노드는 컨테이너를 관리하는 단위이기 때문에 컨테이너가 빠르게 생성되고 종료되는 것이 중요합니다. 이를 위해서는 컨테이너의 리소스 사용량을 최소화하고, 컨테이너의 수를 최대한 늘려야 합니다. 소수의 큰 컨터이너 보다 다수의 작은 컨테이너를 운영하는 것이 물리적인 노드의 리소스를 효율적으로 사용할 수 있는 좋은 방법이기 때문입니다.

여기에 클라우드 네이티브 애플리케이션에서 동시성이 중요한 이유가 있습니다.

작은 컨테이너 단위의 리소스 할당은 작은 수의 스레드를 사용하는 것이 효율이 높다는 말입니다. 작은 수의 스레드를 사용할 수 있다는 것은 컨텍스트 스위칭 비용이 서비스의 효율성과 의존성을 가진다고 볼 수 있습니다.

## 버추얼 스레드 소개

### 버추얼 스레드의 정의

**버추얼 스레드(Virtual Threads)**는 기존의 운영 체제 수준의 스레드보다 훨씬 가벼운 실행 단위입니다. 이는 주로 자바의 [Project Loom](https://openjdk.java.net/projects/loom/)에서 도입된 개념으로, 수천에서 수백만 개의 스레드를 효율적으로 관리할 수 있도록 설계되었습니다. 버추얼 스레드는 물리적 스레드의 오버헤드를 줄이고, 더 높은 동시성을 가능하게 하여 애플리케이션의 성능을 향상시킵니다.

### 전통적인 스레드 모델과의 차이점

전통적인 스레드 모델은 OS 커널에 의해 관리되는 스레드로, 각 스레드는 독립적인 스택과 실행 컨텍스트를 가집니다. 이로 인해 많은 수의 스레드를 생성할 경우, 시스템 자원의 한계에 쉽게 도달할 수 있으며, 컨텍스트 스위칭 비용이 크게 증가합니다. 반면, 버추얼 스레드는 사용자 공간(User Space)에서 관리되며, 경량화된 구조 덕분에 훨씬 적은 자원으로 다수의 스레드를 동시 실행할 수 있습니다.

### Java와 Project Loom에서의 버추얼 스레드 구현

Java의 Project Loom은 버추얼 스레드를 도입하여 JVM의 동시성 모델을 혁신하고자 하는 프로젝트입니다. Project Loom은 기존의 스레드 기반 모델을 보완하여, 더 높은 동시성을 지원하며, 개발자가 더 쉽게 병행 프로그래밍을 수행할 수 있도록 도와줍니다. 이를 통해 Java 애플리케이션은 성능 저하 없이도 많은 수의 스레드를 효율적으로 관리할 수 있게 되었습니다.

## 클라우드 네이티브 애플리케이션에서의 역할

### 동시성 관리의 필요성

클라우드 네이티브 애플리케이션은 다수의 사용자 요청을 동시에 처리(높은 처리량)해야 하며, 이는 높은 수준의 동시성(작은 단위의 컨테이너 운영)을 요구합니다. 효과적인 동시성 관리는 시스템의 응답 속도와 안정성을 유지하는 데 필수적입니다. 버추얼 스레드는 이러한 요구를 충족시키기 위해, 더 많은 동시 실행 단위를 효율적으로 관리할 수 있는 수단을 제공합니다.

### 마이크로서비스 아키텍처와 버추얼 스레드

마이크로서비스 아키텍처는 애플리케이션을 독립적인 서비스 단위로 분할하여 관리합니다. 각 마이크로서비스는 독립적으로 배포되고 확장될 수 있으며, 이는 전체 시스템의 유연성과 확장성을 증가시킵니다. 버추얼 스레드는 이러한 마이크로서비스들이 독립적으로 동작하면서도 높은 처리량을 유지할 수 있도록 지원합니다. 예를 들어, 각 마이크로서비스가 수많은 요청을 처리할 때, 버추얼 스레드를 사용하면 효율적인 자원 관리와 높은 동시성을 실현할 수 있습니다.

### 서버리스 아키텍처와의 연계

서버리스 아키텍처는 개발자가 인프라를 직접 관리하지 않고도 애플리케이션을 개발할 수 있는 환경을 제공합니다. 서버리스 환경에서는 짧은 시간 동안 많은 수의 함수가 실행되기 때문에, 효율적인 동시성 관리가 중요합니다. 버추얼 스레드는 서버리스 아키텍처에서의 높은 동시성을 효과적으로 처리할 수 있는 수단으로, 함수의 실행 효율성을 높이고 응답 시간을 단축시키는 데 기여합니다.

## 버추얼 스레드의 이점

### 리소스 효율성

버추얼 스레드는 매우 적은 메모리와 CPU 자원으로 많은 수의 스레드를 관리할 수 있습니다. 이는 클라우드 환경에서 자원의 낭비를 최소화하고, 더 많은 애플리케이션을 동일한 인프라에서 실행할 수 있게 합니다. 리소스 효율성은 운영 비용 절감과 직결되며, 클라우드 네이티브 애플리케이션의 경제성을 높이는 데 중요한 역할을 합니다.

### 컨텍스트 스위칭 비용 절감

전통적인 스레드는 컨텍스트 스위칭 비용이 높아, 많은 수의 스레드를 사용할 경우 성능 저하가 발생할 수 있습니다. 반면, 버추얼 스레드는 컨텍스트 스위칭의 오버헤드를 크게 줄여줍니다. 이는 시스템 전체의 성능을 향상시키며, 더욱 부드러운 애플리케이션 성능을 보장합니다.

### 높은 동시성 지원

버추얼 스레드는 수천에서 수백만 개의 스레드를 동시에 실행할 수 있어, 높은 동시성을 요구하는 클라우드 네이티브 애플리케이션에 이상적입니다. 이는 사용자 요청에 대한 빠른 응답과 안정적인 서비스 제공을 가능하게 합니다.

## 기존 동시성 모델과의 비교

### 스레드 풀과 버추얼 스레드

스레드 풀은 제한된 수의 스레드를 미리 생성해두고, 작업이 들어올 때마다 이를 할당하여 처리하는 방식입니다. 이 방식은 자원 관리를 효율적으로 할 수 있지만, 스레드 수가 제한적이기 때문에 매우 높은 처리량을 충족시키기 어려울 수 있습니다. 반면, 버추얼 스레드는 동적으로 필요할 때마다 스레드를 생성하고 관리할 수 있어, 스레드 풀이 가지는 한계를 극복할 수 있습니다.

### 코루틴과 버추얼 스레드

코루틴은 경량화된 비동기 함수로, suspend와 resume을 통해 효율적인 비동기 처리를 가능하게 합니다. 코루틴은 단일 스레드 내에서 다수의 비동기 작업을 처리할 수 있어, 리소스 효율성이 높습니다. 그러나 코루틴은 특정 라이브러리나 언어의 지원이 필요하며, 스레드 간의 병렬 처리는 제한적일 수 있습니다. 반면, 버추얼 스레드는 언어와 런타임의 지원을 받아, 병렬 처리를 가능하게 하며, 코루틴의 장점과 스레드의 유연성을 모두 제공합니다.

### Reactive Programming과의 차이점

Reactive Programming은 데이터 스트림과 변화를 중심으로 애플리케이션을 설계하는 패러다임입니다. 이는 비동기 데이터 흐름을 효율적으로 처리할 수 있게 하며, 높은 동시성을 지원합니다. 그러나 Reactive Programming은 복잡한 콜백 체인을 형성할 수 있어, 코드의 가독성이 떨어질 수 있습니다. 버추얼 스레드는 더 직관적인 동시성 관리를 가능하게 하며, 대부분의 동시성 관련 문제를 스레드 기반의 방식으로 해결할 수 있게 합니다.

## 결론

클라우드 네이티브 애플리케이션에서 중요하게 다뤄지는 것 중 하나는 경량화 애플리케이션입니다.

버추얼 스레드는 경량화 애플리케이션을 달성할 수 있는 중요한 개념 중 하나인데요. 특히 컨텍스트 스위칭 비용 절감에 따른 높은 동시성을 지원하고 애플리케이션 처리량을 증가할 수 있도록 이점을 제공합니다.

자바 개발자 혹은 스프링 개발자의 입장에서 본 버추얼 스레드는 기존 애플리케이션의 환경을 유지하면서 경량화 애플리케이션으로 쉽게 전환할 수 있도록 도와주는 좋은 방법으로 느껴집니다.

## 참고 자료

1. [Project Loom 공식 웹사이트](https://openjdk.java.net/projects/loom/)
2. [Java Virtual Threads](https://www.baeldung.com/java-virtual-threads)
3. [Understanding Cloud Native Applications](https://kubernetes.io/docs/concepts/overview/what-is-cloud-native/)
4. [Concurrency vs Parallelism](https://martinfowler.com/articles/concurrency-vs-parallelism.html)
5. [Reactive Programming with Spring](https://spring.io/reactive)
6. [Coroutines in Kotlin](https://kotlinlang.org/docs/coroutines-overview.html)
7. [Go's Goroutines](https://golang.org/doc/effective_go.html#goroutines)
8. [Kubernetes Scalability Planning](https://cloud.google.com/kubernetes-engine/docs/concepts/planning-scalability?hl=ko)
9. [Horizontal Pod Autoscaler (HPA)](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
10. [Cluster Autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler)

## 지난 기록

- [클라우드 네이티브 애플리케이션: 경량 애플리케이션의 중요성과 Context Switching 문제 해결 방안](https://yeti.tistory.com/385)
- [클라우드 네이티브 애플리케이션: 탄생 배경부터 현황까지](https://yeti.tistory.com/382)
- [동시성과 병렬성의 이해: Context Switching](https://yeti.tistory.com/381)
- [동시성과 병렬성의 이해: 동기, 비동기, 블로킹, 논블로킹의 개념](https://yeti.tistory.com/380)
- [동시성과 병렬성의 이해: 멀티스레딩 vs 멀티프로세싱](https://yeti.tistory.com/379)