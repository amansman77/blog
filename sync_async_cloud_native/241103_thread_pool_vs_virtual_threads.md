# 스레드 풀과 버추얼 스레드의 비교 (feat. 클라우드 네이티브 애플리케이션)

안녕하세요. yeTi입니다.
오늘은 클라우드 네이티브 애플리케이션에서 스레드 풀과 버추얼 스레드의 비교를 해보려고 합니다.

## 서론

소프트웨어 개발 분야에서 **동시성**과 **병렬성** 관리는 효율적이고 반응성 높은 애플리케이션을 구축하는 데 필수적입니다. 특히 **클라우드 네이티브 애플리케이션**에서는 확장성과 자원 최적화가 중요한데, 이러한 요구사항을 만족시키기 위해 적절한 동시성 모델의 선택이 매우 중요합니다.

본 글에서는 자바에서 제공하는 두 가지 주요 동시성 모델인 **스레드 풀(Thread Pool)**과 **버추얼 스레드(Virtual Thread)**를 비교 분석합니다. 각 모델의 특징, 장단점, 그리고 클라우드 네이티브 애플리케이션에서의 적용 가능성을 살펴봄으로써 개발자들이 적절한 동시성 모델을 선택하는 데 필요한 인사이트를 제공하고자 합니다.

## 스레드 풀 이해하기

### 정의 및 기본 개념

**스레드 풀**은 미리 생성된 스레드들의 집합을 관리하는 방식입니다. 새로운 작업이 발생할 때마다 스레드를 새로 생성하는 대신, 풀에 존재하는 스레드를 재사용하여 작업을 처리함으로써 자원 관리와 성능을 최적화합니다.

### 스레드 풀의 동작 방식

스레드 풀은 작업 큐와 재사용 가능한 스레드들로 구성됩니다. 새로운 작업이 도착하면, 풀에 유휴 상태인 스레드가 작업을 할당받아 실행합니다. 만약 모든 스레드가 바쁘게 작업을 수행 중이라면, 추가 작업은 큐에 대기하게 됩니다. 이를 통해 스레드 생성과 소멸에 따른 오버헤드를 줄이고 성능을 향상시킬 수 있습니다.

### 스레드 풀의 장점

- **자원 관리 효율성**: 제한된 수의 스레드를 효과적으로 관리하여 자원 낭비를 방지합니다.
- **성능 향상**: 스레드 재사용을 통해 작업 처리 속도를 높이고, 스레드 생성/소멸에 따른 비용을 절감합니다.
- **시스템 안정성**: 과도한 스레드 생성을 방지하여 시스템의 안정성을 유지합니다.

### 스레드 풀의 단점

- **제한된 동시성**: 풀에 설정된 스레드 수가 동시 처리 능력을 제한할 수 있습니다.
- **I/O 비효율성**: I/O 바운드 작업이 많은 경우, 스레드가 블로킹되면서 효율성이 떨어질 수 있습니다.

## 버추얼 스레드 이해하기

### 정의 및 소개

**버추얼 스레드(Virtual Thread)** 는 자바 21에서 도입된 경량 스레드 구현 방식입니다. 기존의 OS 스레드와 달리 JVM 내부에서 관리되는 경량 스레드로, 매우 적은 리소스로 수백만 개의 스레드를 동시에 생성하고 관리할 수 있습니다.

### 자바에서의 구현 (Project Loom)

Java의 **Project Loom**은 버추얼 스레드를 도입하여 JVM의 동시성 모델을 혁신하고자 하는 프로젝트입니다. Project Loom은 기존의 스레드 기반 모델을 보완하여, 더 높은 동시성을 지원하며, 개발자가 더 쉽게 병행 프로그래밍을 수행할 수 있도록 도와줍니다. 이를 통해 Java 애플리케이션은 성능 저하 없이도 많은 수의 스레드를 효율적으로 관리할 수 있게 되었습니다.

### 버추얼 스레드의 장점

- **리소스 효율성**: 버추얼 스레드는 매우 적은 메모리와 CPU 자원으로 많은 수의 스레드를 관리할 수 있습니다. 이는 클라우드 환경에서 자원의 낭비를 최소화하고, 더 많은 애플리케이션을 동일한 인프라에서 실행할 수 있게 합니다.
- **컨텍스트 스위칭 비용 절감**: 전통적인 스레드는 컨텍스트 스위칭 비용이 높아, 많은 수의 스레드를 사용할 경우 성능 저하가 발생할 수 있습니다. 반면, 버추얼 스레드는 컨텍스트 스위칭의 오버헤드를 크게 줄여줍니다.
- **높은 동시성 지원**: 버추얼 스레드는 수천에서 수백만 개의 스레드를 동시에 실행할 수 있어, 높은 동시성을 요구하는 클라우드 네이티브 애플리케이션에 이상적입니다.
- **효율적인 I/O 처리**: I/O 작업 시 JVM이 가상 스레드를 중지시키고 다른 가상 스레드를 실행하여 처리량을 높입니다.
- **쉬운 사용법**: 기존의 Thread API와 유사한 방식으로 사용할 수 있어 학습 곡선이 낮습니다.

### 버추얼 스레드의 단점

- **CPU 집약적 작업에 부적합**: CPU 집약적 작업에는 적합하지 않을 수 있습니다.
- **ThreadLocal 사용 시 주의**: 많은 수의 스레드를 사용할 경우 ThreadLocal 사용 시 메모리 사용량 증가와 관리의 어려움이 발생할 수 있습니다.

## 비교 분석

### 자원 활용도

- **스레드 풀**:
  - 제한된 수의 OS 스레드를 사용합니다.
  - OS 수준의 스레드 관리로 인해 각 스레드당 메모리 사용량이 상대적으로 높습니다.
  
- **버추얼 스레드**:
  - 매우 적은 리소스로 대량의 스레드를 생성할 수 있습니다.
  - JVM 내부에서 관리되므로 메모리 및 CPU 사용량이 효율적입니다.

### 동시성 및 확장성

- **스레드 풀**:
  - 풀에 설정된 스레드 수에 따라 동시성에 한계가 있습니다.
  - 풀 크기 이상의 작업은 큐에 대기하게 되어 처리량이 제한될 수 있습니다.
  
- **버추얼 스레드**:
  - 수백만 개의 스레드를 동시에 실행할 수 있어 높은 확장성을 자랑합니다.
  - 동적으로 필요에 따라 스레드를 생성하고 관리할 수 있습니다.

### I/O vs CPU 바운드 작업

- **스레드 풀**:
  - CPU 바운드 작업에는 적합하지만, I/O 바운드 작업에서는 스레드가 블로킹되어 효율성이 떨어질 수 있습니다.
  
- **버추얼 스레드**:
  - I/O 바운드 작업에 뛰어난 성능을 발휘하며, 블로킹 시 다른 스레드가 작업을 계속할 수 있어 효율적입니다.
  - CPU 바운드 작업에서는 성능이 제한적일 수 있습니다.

### 구현 복잡성

- **스레드 풀**:
  - `ExecutorService` 등을 통해 비교적 쉽게 구현할 수 있습니다.
  - 기존 스레드 기반 애플리케이션과의 호환성이 좋습니다.
  
- **버추얼 스레드**:
  - Java 21 이상에서 간단히 사용할 수 있으며, 기존 코드의 마이그레이션 시 일부 주의가 필요합니다.
  - ThreadLocal 사용 시 추가적인 관리가 필요할 수 있습니다.

### 컨텍스트 스위칭 오버헤드

- **스레드 풀**:
  - OS 스레드의 컨텍스트 스위칭 비용이 상대적으로 높습니다.
  
- **버추얼 스레드**:
  - JVM 수준에서 관리되어 컨텍스트 스위칭 비용이 크게 감소합니다.
  - 시스템 전체의 성능 및 반응성을 향상시킵니다.

## 사용 시기

### 스레드 풀 사용 시기

- CPU 집약적 작업이 주를 이루는 애플리케이션
- 제한된 수의 동시 처리가 필요한 상황
- 기존 스레드 기반 아키텍처를 유지하면서 성능을 향상시키고자 할 때

### 버추얼 스레드 사용 시기

- I/O 바운드 작업이 많은 서버 애플리케이션
- 높은 동시성을 요구하는 클라우드 네이티브 애플리케이션
- 기존 코드와의 호환성을 유지하면서 스레드 수를 크게 늘리고자 할 때

## 결론

**스레드 풀**과 **버추얼 스레드**는 각각의 장단점을 가지고 있어, 애플리케이션의 요구사항에 따라 적절히 선택하는 것이 중요합니다. CPU 바운드 작업이 주를 이루는 환경에서는 스레드 풀이 여전히 유효한 선택일 수 있지만, I/O 바운드 작업이 많은 클라우드 네이티브 애플리케이션에서는 버추얼 스레드가 더 나은 성능과 효율성을 제공할 수 있습니다.

제 개인적인 경험에 비추어 보면 요즘에는 AWS, GCP, Azure 등의 클라우드 환경에서 서비스를 운영하는 경우가 많았고, 서비스의 구조도 I/O 바운드 작업이 많은 경우가 대부분이었습니다. 따라서 Spring Boot 를 활용하는 Java 개발 환경에서는 Java 21 을 사용하여 버추얼 스레드를 사용하는 것이 더 효율적일 것으로 예상합니다.

## 참고 자료

1. [Project Loom 공식 웹사이트](https://openjdk.java.net/projects/loom/)
2. [Java Virtual Threads](https://www.baeldung.com/java-virtual-threads)
3. [Understanding Cloud Native Applications](https://kubernetes.io/docs/concepts/overview/what-is-cloud-native/)
4. [Concurrency vs Parallelism](https://martinfowler.com/articles/concurrency-vs-parallelism.html)
5. [Reactive Programming with Spring](https://spring.io/reactive)
6. [Coroutines in Kotlin](https://kotlinlang.org/docs/coroutines-overview.html)
7. [Go's Goroutines](https://golang.org/doc/effective_go.html#goroutines)
8. [Kubernetes Scalability Planning](https://cloud.google.com/kubernetes-engine/docs/concepts/planning-scalability?hl=ko)
9. [Horizontal Pod Autoscaler (HPA)](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
10. [Cluster Autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler)

## 지난 기록

- [클라우드 네이티브 애플리케이션에서 버추얼 스레드의 역할과 이점](https://yeti.tistory.com/388)
- [클라우드 네이티브 애플리케이션: 경량 애플리케이션의 중요성과 Context Switching 문제 해결 방안](https://yeti.tistory.com/385)
- [클라우드 네이티브 애플리케이션: 탄생 배경부터 현황까지](https://yeti.tistory.com/382)
- [동시성과 병렬성의 이해: Context Switching](https://yeti.tistory.com/381)
- [동시성과 병렬성의 이해: 동기, 비동기, 블로킹, 논블로킹의 개념](https://yeti.tistory.com/380)
- [동시성과 병렬성의 이해: 멀티스레딩 vs 멀티프로세싱](https://yeti.tistory.com/379)
