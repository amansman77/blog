# ChatGPT 와 대화한 내용

--- 질문1

질문: MariaDB(10.6.18) 의 Galera 클러스터 설정시 SST 로 rsync 를 사용했어.
rsync 를 묻따풀해보고 싶어.

답변: `rsync`는 파일과 디렉터리를 효율적으로 동기화하고 전송하는 유용한 도구로, MariaDB Galera 클러스터의 SST(State Snapshot Transfer)에서 자주 사용됩니다. 이를 깊게 이해하고자 할 때, 아래 내용을 통해 하나씩 풀어보겠습니다.

---

### 1. **rsync의 역할**
- **Galera 클러스터에서 rsync 사용**  
  Galera 클러스터는 새로운 노드가 클러스터에 합류할 때 기존 노드에서 데이터를 가져와 초기 동기화를 수행합니다. 이 과정이 **SST**입니다.  
  `rsync`는 데이터를 델타 전송(delta transfer) 방식으로 복사하여 효율적으로 동기화합니다.

- **rsync가 필요한 이유**  
  1. 네트워크 대역폭 절약: 차이점만 전송합니다.
  2. 파일 무결성 유지: 전송된 파일이 원본과 동일한지 검증합니다.
  3. 속도: 대규모 데이터 동기화에 적합합니다.

---

### 2. **MariaDB에서 rsync로 SST 구성**
#### 설정 예시 (`my.cnf`):
```ini
[mysqld]
wsrep_provider=/usr/lib/galera/libgalera_smm.so
wsrep_sst_method=rsync
wsrep_cluster_address=gcomm://<노드1>,<노드2>,<노드3>
```

- `wsrep_sst_method=rsync`: SST 방식으로 rsync 사용을 지정합니다.
- `wsrep_cluster_address`: 클러스터의 다른 노드를 지정합니다.

---

### 3. **rsync의 동작 방식**
#### 기본 rsync 명령:
```bash
rsync -avz source_directory/ destination_directory/
```

- `-a` : 아카이브 모드(소스 파일의 권한, 타임스탬프 등 속성 보존).
- `-v` : 전송 중 상세한 정보를 출력.
- `-z` : 데이터 압축을 활성화.

#### MariaDB에서 SST 과정:
1. Donor 노드에서 `rsync` 서버가 활성화되어 데이터가 준비됩니다.
2. Joiner 노드에서 `rsync`를 통해 Donor의 데이터를 가져옵니다.
3. 데이터를 동기화한 후 Galera의 Replication이 시작됩니다.

---

### 4. **rsync 사용 시 주의점**
- **권한 문제**: 
  SST 과정에서 `rsync`는 MariaDB 데이터 디렉터리에 접근합니다. 권한 문제가 발생하지 않도록 디렉터리와 파일 권한을 확인하세요.
  ```bash
  chown -R mysql:mysql /var/lib/mysql
  ```

- **네트워크 속도**:
  대용량 데이터 전송 시 네트워크 병목이 발생할 수 있습니다. 적절한 네트워크 환경을 구성하세요.

- **방화벽 설정**:
  `rsync`는 TCP 포트 873을 사용하므로 방화벽에서 열려 있어야 합니다.
  ```bash
  ufw allow 873/tcp
  ```

---

### 5. **rsync 실패 시 디버깅**
- **로그 확인**:
  `journalctl`이나 MariaDB 로그에서 실패 원인을 찾을 수 있습니다.
  ```bash
  journalctl -u mariadb
  ```

- **수동 rsync 테스트**:
  Donor와 Joiner 간에 `rsync` 명령을 수동으로 실행하여 네트워크와 파일 권한 문제를 점검합니다.
  ```bash
  rsync -avz /var/lib/mysql/ user@joiner:/var/lib/mysql/
  ```

- **mariabackup과 비교**:
  `rsync`로 SST가 실패할 경우, `mariabackup` 방법을 시도하여 비교 분석합니다.

---

### 6. **mariabackup과 rsync 비교**
| **특징**           | **rsync**                                | **mariabackup**                            |
|---------------------|------------------------------------------|-------------------------------------------|
| 설정 용이성        | 쉽다                                     | 추가 설정 필요                            |
| 데이터 전송 속도   | 빠르지만 대역폭에 의존                   | 압축 및 병렬 처리 지원으로 효율적         |
| 무결성 보장        | 파일 무결성 체크                         | 데이터 무결성 및 일관성 보장               |
| 사용 사례          | 작은 규모 클러스터                       | 대규모 클러스터                            |

---

`rsync`는 설정과 디버깅이 비교적 간단하고, 작은 데이터 규모에서는 매우 효율적입니다. 그러나 대규모 클러스터에서는 `mariabackup`이 더 적합할 수 있습니다. MariaDB Galera 클러스터에서 `rsync`를 계속 사용할 계획이라면 위 내용을 참고하여 성능과 안정성을 높이는 방향으로 점검해보세요!

--- 질문2

질문: rsync 는 뭐야? 오픈소스야? 아니면 마리아 DB 재단에서 만든 도구야?

답변: `rsync`는 오픈소스 도구입니다. MariaDB나 Galera 클러스터에서 만든 것이 아니라, 데이터 동기화와 파일 전송을 위해 독립적으로 개발된 범용적인 파일 복사 및 동기화 유틸리티입니다.

---

### **`rsync`의 기본 정보**
1. **개발 및 소스**:
   - `rsync`는 1996년 Andrew Tridgell과 Paul Mackerras에 의해 처음 개발되었습니다.
   - 현재 오픈소스 커뮤니티에 의해 유지 및 관리되고 있으며, GNU GPL 라이선스 하에 배포됩니다.
   - GitHub나 Linux 배포판에서 쉽게 소스 코드를 확인하거나 설치할 수 있습니다.

2. **주요 특징**:
   - **효율적인 데이터 전송**: 델타 인코딩(Delta Encoding) 기법을 사용하여 변경된 부분만 전송.
   - **네트워크 대역폭 절약**: 기존 데이터를 재사용하고, 전송 데이터를 압축.
   - **광범위한 플랫폼 지원**: 대부분의 Unix/Linux 및 macOS 시스템에서 기본적으로 사용 가능.

3. **MariaDB와의 관계**:
   - MariaDB나 Galera 클러스터와 직접적인 관계는 없습니다.
   - Galera 클러스터의 **SST(State Snapshot Transfer)** 과정에서 파일 전송을 위해 `rsync`를 사용하는 옵션이 제공될 뿐입니다.
   - MariaDB 외에도 다양한 프로젝트에서 파일 동기화를 위해 활용됩니다.

---

### **오픈소스의 장점**
`rsync`가 오픈소스라는 점은 다음과 같은 이점을 제공합니다:
1. **무료 사용**: 상용 소프트웨어와 달리 비용 없이 사용할 수 있습니다.
2. **커스터마이징 가능**: 소스 코드를 수정하여 특정 요구사항에 맞게 조정할 수 있습니다.
3. **활발한 커뮤니티 지원**: 전 세계 개발자들로부터 지속적인 업데이트와 버그 수정이 이루어집니다.
4. **플랫폼 독립성**: Linux, macOS, Windows(Cygwin 등 활용)에서 모두 실행 가능.

---

### **`rsync`와 MariaDB를 함께 사용하는 이유**
MariaDB와 Galera 클러스터에서 `rsync`를 사용하는 이유는 간단합니다:
- 데이터를 효율적으로 전송하고, 클러스터 노드 간 동기화를 간소화하기 위함입니다.
- 다른 SST 방법(`mariabackup`, `xtrabackup` 등)에 비해 설정이 간단하며, 추가적인 도구 설치가 필요 없습니다.

---

### **결론**
- **`rsync`는 MariaDB 재단이나 Galera 팀에서 개발한 도구가 아닙니다.**
- 범용적으로 파일 전송과 동기화를 위해 설계된 오픈소스 도구입니다.
- MariaDB는 `rsync`의 간단하고 효율적인 동작을 활용하여 클러스터 동기화를 지원하고 있을 뿐입니다.

추가적으로, `rsync`가 오픈소스라는 점은 MariaDB나 다른 프로젝트에서 자유롭게 사용할 수 있는 기반을 제공하며, 필요하다면 직접 확장하거나 커스터마이징할 수 있습니다.

--- 질문3

질문: MariaDB 재단이나 Galera 팀은 SST 방식으로 왜 rsync 를 선택했을까?

답변: MariaDB 재단이나 Galera 팀이 SST(State Snapshot Transfer) 방식 중 하나로 `rsync`를 선택한 이유는 다음과 같은 **단순성과 효율성**에 있습니다. 

---

### **1. 간단하고 검증된 도구**
- **설정이 간단**:
  - `rsync`는 대부분의 Linux 배포판에서 기본적으로 제공되며, 추가 설치 없이 바로 사용할 수 있습니다.
  - 별도의 복잡한 설정 없이 MariaDB 클러스터에서 바로 적용 가능.
  
- **광범위한 활용 경험**:
  - `rsync`는 1990년대부터 사용되어 온 안정적이고 검증된 파일 동기화 도구로, 커뮤니티와 산업에서 신뢰받고 있습니다.
  - MariaDB와 같은 데이터베이스에서도 신뢰할 수 있는 성능을 제공합니다.

---

### **2. 델타 전송의 효율성**
- **부분 데이터 전송(Delta Transfer)**:
  - `rsync`는 기존 데이터를 분석해 변경된 부분만 전송하므로 네트워크 대역폭을 절약합니다.
  - 대용량 데이터베이스 파일을 초기화하는 SST 작업에서 성능상의 이점이 있습니다.

- **압축 지원**:
  - 전송 중 데이터를 압축해 네트워크와 전송 시간을 최소화합니다.

---

### **3. 최소 요구 사항**
- **추가 의존성 없음**:
  - `rsync`는 외부 라이브러리나 소프트웨어를 추가로 설치하지 않아도 됩니다.
  - 반면, `mariabackup`이나 `xtrabackup` 같은 도구는 별도의 설치와 설정이 필요합니다.

- **적은 시스템 자원 사용**:
  - `rsync`는 CPU 및 메모리 사용량이 비교적 낮아 작은 클러스터나 리소스가 제한된 환경에서도 적합합니다.

---

### **4. 다양한 사용 시나리오에 적합**
- **소규모 클러스터에 적합**:
  - 초기 설정과 실행이 간단해, 소규모 클러스터나 테스트 환경에서 유용합니다.
  
- **데이터 보존**:
  - 파일의 권한, 타임스탬프, 심볼릭 링크 등을 포함한 원본 상태를 그대로 보존하여 데이터 무결성을 유지합니다.

---

### **5. 데이터베이스의 특성에 맞춘 선택**
- **MariaDB 데이터 구조와의 적합성**:
  - MariaDB의 데이터 디렉터리는 파일 기반 구조(데이터베이스 파일, 로그 파일 등)로 구성됩니다.  
  - `rsync`는 파일 단위의 동기화에 최적화되어 있어 이러한 구조에 잘 맞습니다.
  
- **단순한 SST 흐름**:
  - `rsync`는 Donor 노드(기존 노드)가 Joiner 노드(새 노드)로 데이터를 단순히 복사하는 역할을 수행합니다.  
  - 복잡한 데이터베이스 백업/복구 절차를 필요로 하지 않기 때문에 안정적으로 작동합니다.

---

### **6. `rsync`를 SST 방식으로 선택한 한계**
Galera 팀이 `rsync`를 선택했지만, 몇 가지 한계도 있습니다:
- **클러스터 중단 필요**:
  - `rsync`를 사용하는 동안 Donor 노드는 쓰기 작업을 일시 중지해야 하므로 클러스터의 가용성이 낮아질 수 있습니다.
- **성능 한계**:
  - 매우 대규모 데이터베이스의 경우 `rsync`는 전송 시간이 오래 걸릴 수 있습니다.
  - 이러한 상황에서는 `mariabackup` 같은 고성능 SST 방법이 더 적합할 수 있습니다.

---

### **결론**
Galera 팀과 MariaDB 재단이 `rsync`를 SST 방식으로 선택한 이유는 **간단함, 안정성, 효율성** 때문입니다. 특히 소규모 클러스터나 복잡하지 않은 환경에서 `rsync`는 매우 적합한 도구입니다. 그러나 대규모 환경에서는 성능상의 한계로 인해 `mariabackup` 같은 대안적인 SST 방법이 필요할 수 있습니다. 

이러한 선택은 사용자가 요구하는 환경과 클러스터의 특성에 따라 적절히 조정하면 됩니다.

--- 질문4

질문: 그러면 마리아 디비의 클러스터를 시작하는 단계에서는 rsync 를 적용하는 것이 좋을 수 있겠다.
그러면 언제 mariabackup 같은 대안적인 SST 로 전환하는 것을 고려해야 할까?

답변: MariaDB의 클러스터를 시작하는 초기 단계에서는 **`rsync`**가 설정과 운영이 간단하고 효율적이기 때문에 좋은 선택이 될 수 있습니다. 하지만 클러스터의 규모가 커지거나 사용 사례가 복잡해질 경우, **`mariabackup`**과 같은 대안적인 SST(State Snapshot Transfer) 방법으로 전환하는 것이 적합한 상황이 있습니다. 이를 아래와 같이 정리할 수 있습니다.

---

## **1. `mariabackup`으로 전환을 고려해야 할 상황**

### **1.1 클러스터 노드가 대용량 데이터를 다루는 경우**
- 데이터베이스가 매우 크고 **수십 기가바이트(GiB) 이상**의 데이터를 포함할 때, `rsync`는 전체 데이터를 복사하는 동안 시간이 오래 걸릴 수 있습니다.
- **`mariabackup`은 증분 백업과 병렬 처리를 지원**하여 대용량 데이터 전송에서 더 효율적입니다.

---

### **1.2 클러스터의 가용성을 유지해야 하는 경우**
- **`rsync`의 한계**:
  - SST 중 Donor 노드는 쓰기 작업을 중단해야 합니다. 이는 가용성에 영향을 미칠 수 있습니다.
  - 특히, 클러스터의 나머지 노드에서 실시간 쓰기 작업이 필요한 경우 문제가 됩니다.

- **`mariabackup`의 장점**:
  - Donor 노드의 데이터베이스를 오프라인 상태로 만들지 않고도 백업을 수행할 수 있습니다.  
  - **"hot backup"**을 통해 서비스 중단 없이 SST를 처리합니다.

---

### **1.3 고성능이 요구되는 환경**
- **`rsync`의 성능 한계**:
  - `rsync`는 파일 단위로 데이터를 동기화하므로, 작은 파일이 많은 경우 오히려 비효율적일 수 있습니다.
  - 네트워크 대역폭이 제한적이거나 데이터 전송 시간이 중요한 경우 성능이 저하될 수 있습니다.

- **`mariabackup`의 이점**:
  - 데이터 압축과 병렬 전송을 지원하여 대규모 데이터베이스에서 더 나은 성능을 제공합니다.
  - IO(입출력) 작업 최적화로 전송 속도를 향상시킵니다.

---

### **1.4 데이터 일관성과 무결성이 중요한 경우**
- **`rsync`의 한계**:
  - 단순 파일 복사를 수행하며, 데이터베이스의 일관성(consistency)을 보장하지 못할 수 있습니다.
  - 클러스터에서 트랜잭션을 포함한 데이터 무결성을 확인하기 어렵습니다.

- **`mariabackup`의 장점**:
  - 데이터베이스의 **트랜잭션 로그와 데이터를 동시에 백업**하여 데이터 일관성을 보장합니다.
  - 복구 시점의 데이터 무결성을 확보할 수 있습니다.

---

### **1.5 클러스터 노드 수가 많아질 때**
- **`rsync`의 한계**:
  - 클러스터의 노드 수가 많아질수록 SST 수행 중 각 노드 간의 부하와 네트워크 병목이 발생할 수 있습니다.
  - 특히, 다수의 Joiner 노드가 동시에 합류하는 경우 Donor 노드에 과부하가 걸릴 가능성이 큽니다.

- **`mariabackup`의 이점**:
  - 병렬 처리를 통해 여러 Joiner 노드에서 동시에 SST 작업을 수행하는 데 적합합니다.
  - 대규모 클러스터에서 더 안정적으로 동작합니다.

---

## **2. `mariabackup`으로 전환을 결정하는 기준**
아래 기준에 부합하면 `mariabackup`으로 전환을 고려하세요:

1. **데이터베이스 크기**: 데이터베이스 크기가 10GB 이상으로 증가.
2. **가용성 요구**: 클러스터가 항상 가동되어야 하는 환경.
3. **노드 증가**: 클러스터 노드 수가 3개 이상으로 확장.
4. **성능 문제**: `rsync`의 속도가 느리거나 병목이 발생.
5. **데이터 무결성 요구**: 트랜잭션 기반 서비스에서 데이터 일관성이 중요.

---

## **3. 전환 시 고려 사항**
1. **추가 설정**:
   - `mariabackup`을 사용하려면 MariaDB 환경에 맞는 추가 설정과 도구 설치가 필요합니다.
   - 예: `wsrep_sst_method=mariabackup`으로 변경하고 `mariabackup`을 설치.

2. **테스트 환경 구축**:
   - 운영 클러스터에 적용하기 전에 테스트 클러스터에서 `mariabackup`의 성능과 안정성을 충분히 검증하세요.

3. **도구 버전 확인**:
   - MariaDB와 `mariabackup`의 버전 호환성을 확인해야 합니다.

---

## **결론**
- 클러스터의 **초기 설정**이나 **소규모 환경**에서는 `rsync`가 간단하고 효율적인 선택입니다.
- 그러나 **데이터 규모가 증가하거나, 가용성과 성능이 중요해지는 단계**에서는 `mariabackup`으로 전환을 검토해야 합니다.
- 두 가지 방법을 환경에 맞게 조합해 사용하되, 테스트와 모니터링을 통해 최적의 설정을 찾는 것이 중요합니다.

--- 질문5

질문: 데이터베이스 크기가 10GB 이상으로 증가하는 기준으로 mariabackup으로 전환을 고려한 이유가 뭐야?

답변: 데이터베이스 크기가 **10GB 이상으로 증가**하면 SST(State Snapshot Transfer) 방식으로 `mariabackup`을 고려하는 이유는 **`rsync`의 구조적 한계**와 **`mariabackup`의 성능 최적화**가 관련되어 있습니다. 아래에서 그 이유를 구체적으로 설명합니다.

---

### 1. **rsync의 구조적 한계**
`rsync`는 **파일 단위의 동기화**를 수행하며, 데이터베이스 파일이 클수록 몇 가지 문제를 야기할 수 있습니다:

#### **1.1 전체 파일 복사**
- **rsync의 동작**:
  - 데이터를 델타(변경된 부분)로 전송하더라도, **파일 전체를 읽고 변경된 부분을 식별**하는 과정이 필요합니다.
  - 데이터베이스 파일이 크면 이 과정이 오래 걸리고, I/O 부하가 증가합니다.
  
- **10GB 이상의 데이터베이스 문제**:
  - 데이터베이스 파일은 일반적으로 매우 큰 단일 파일(예: `ibdata1`)이거나 다수의 큰 테이블 스페이스 파일로 구성됩니다.
  - 파일 크기가 클수록 데이터 전송 시간과 CPU/디스크 부하가 급격히 증가합니다.

---

#### **1.2 데이터베이스 파일의 잠금 문제**
- `rsync`는 **파일 시스템 단위의 복사**를 수행하기 때문에, SST 동안 Donor 노드는 쓰기 작업을 중단해야 합니다.
- **10GB 이상의 데이터베이스**에서는 SST가 오래 걸릴 수 있어 클러스터의 가용성이 심각하게 저하될 수 있습니다.
  - 특히, 읽기 및 쓰기 요청이 빈번한 운영 환경에서는 서비스 중단 시간이 문제가 됩니다.

---

### 2. **mariabackup의 성능 최적화**
`mariabackup`은 **MariaDB 전용 백업 도구**로 설계되어 있어, 대규모 데이터베이스 전송 시 다음과 같은 강점을 제공합니다:

#### **2.1 병렬 처리**
- **병렬 데이터 전송**:
  - `mariabackup`은 데이터를 병렬로 읽고 전송할 수 있어 대규모 데이터베이스에서도 효율적입니다.
  - CPU 코어와 네트워크 대역폭을 최대한 활용하여 전송 속도를 향상시킵니다.

#### **2.2 Hot Backup 지원**
- **쓰기 작업 중단 없음**:
  - `mariabackup`은 데이터베이스의 트랜잭션 로그를 읽으면서 **쓰기 작업을 중단하지 않고** 데이터를 복사합니다.
  - 이는 서비스의 **가용성을 유지**하며 SST를 수행할 수 있도록 합니다.

#### **2.3 데이터 압축 및 증분 백업**
- **압축**:
  - 전송 데이터를 압축하여 네트워크 대역폭을 줄이고, 전송 시간을 단축합니다.
- **증분 백업**:
  - 이미 백업된 데이터는 재전송하지 않으므로 **큰 데이터베이스의 전송 시간**이 크게 감소합니다.

#### **2.4 데이터 무결성 보장**
- **트랜잭션 일관성**:
  - `mariabackup`은 복사 시 트랜잭션 로그를 함께 백업하여, **데이터베이스의 일관성과 무결성**을 보장합니다.
  - 이는 데이터 손실 가능성을 최소화하며, 특히 대규모 데이터베이스에서 중요합니다.

---

### 3. **10GB 이상의 데이터에서 mariabackup이 적합한 이유**
| **기준**                | **rsync**                                                  | **mariabackup**                                          |
|-------------------------|----------------------------------------------------------|--------------------------------------------------------|
| **데이터 크기**         | 10GB 이상의 대규모 데이터베이스에서 성능 저하 발생          | 대용량 데이터를 병렬 처리 및 압축으로 효율적으로 처리      |
| **서비스 중단 여부**    | Donor 노드의 쓰기 작업 중단 필요                            | Donor 노드의 쓰기 작업을 중단하지 않음                  |
| **데이터 일관성**       | 파일 단위 복사로 인해 데이터베이스의 일관성을 보장하지 않음  | 트랜잭션 로그와 함께 데이터를 백업하여 데이터 무결성 보장 |
| **전송 시간**           | 파일 크기에 따라 오래 걸릴 수 있음                          | 증분 백업과 병렬 처리를 통해 전송 시간 단축              |
| **리소스 활용**         | 단일 스레드 기반, CPU 및 I/O 부하 증가                      | 병렬 작업으로 CPU와 네트워크를 최적화하여 사용           |

---

### 4. **결론**
데이터베이스 크기가 **10GB 이상으로 증가**하는 경우:
1. **rsync의 전송 시간 증가**와 **Donor 노드의 가용성 저하** 문제가 발생할 가능성이 높아집니다.
2. **mariabackup**은 병렬 처리, 압축, 증분 백업, 트랜잭션 일관성을 지원하여 더 빠르고 안전한 SST를 보장합니다.

따라서, **대규모 데이터베이스** 또는 **서비스 중단이 용납되지 않는 환경**에서는 `mariabackup`으로 전환하는 것이 적합합니다. 이를 통해 안정성과 성능을 모두 확보할 수 있습니다.

--- 질문6

질문: 클러스터 노드 수가 3개 이상으로 확장하는 기준으로 mariabackup으로 전환을 고려한 이유가 뭐야?

답변: MariaDB Galera 클러스터에서 노드 수가 **3개 이상으로 확장**될 때 **`mariabackup`**으로 SST(State Snapshot Transfer) 방식을 전환하는 것을 고려하는 이유는 다음과 같은 **성능, 확장성, 가용성 문제**와 관련이 있습니다.

---

### **1. rsync 방식의 한계**
`rsync`는 작은 클러스터(예: 2~3개 노드)에서는 간단하고 효과적이지만, 노드 수가 늘어나면 여러 제한 사항이 나타납니다.

#### **1.1 동시 SST 요청 증가**
- **문제**:
  - 클러스터에 새로운 Joiner 노드가 추가될 때, Donor 노드는 데이터를 전송하는 작업(SST)을 수행합니다.
  - 여러 Joiner 노드가 **동시에 SST 요청**을 보내면 Donor 노드에 과부하가 걸릴 수 있습니다.
  
- **rsync의 한계**:
  - `rsync`는 각 Joiner 노드에 대해 **직렬 방식으로 SST를 수행**합니다.
  - 노드 수가 많아질수록 SST 시간이 길어지고, Donor 노드의 리소스(CPU, 디스크 I/O, 네트워크 대역폭)가 고갈될 가능성이 높아집니다.

#### **1.2 Donor 노드의 서비스 중단**
- **문제**:
  - `rsync`는 Donor 노드에서 데이터를 전송하는 동안 **쓰기 작업을 중단**해야 합니다.
  - 여러 노드가 합류하는 대규모 클러스터에서는 이로 인해 서비스 중단 시간이 길어질 수 있습니다.

- **노드가 3개 이상일 때의 영향**:
  - 클러스터의 가용성이 저하되고, 사용자 요청이 제대로 처리되지 않을 가능성이 커집니다.

---

### **2. mariabackup의 장점**
`mariabackup`은 대규모 클러스터 환경에서 `rsync`의 한계를 보완하기 위해 설계된 백업 도구입니다.

#### **2.1 병렬 SST 수행**
- **장점**:
  - `mariabackup`은 여러 Joiner 노드가 동시에 SST 요청을 보내도 Donor 노드에서 병렬로 SST를 처리할 수 있습니다.
  - Donor 노드의 부하를 최소화하며 SST 시간을 단축시킵니다.

#### **2.2 서비스 중단 없이 동작**
- **장점**:
  - `mariabackup`은 "hot backup" 방식을 사용하여 Donor 노드가 SST를 수행하는 동안에도 쓰기 작업을 중단하지 않습니다.
  - 클러스터의 가용성을 유지하며, 사용자 요청에 대한 응답을 보장합니다.

#### **2.3 노드 수 증가에 따른 확장성 제공**
- **장점**:
  - 대규모 클러스터 환경에서도 효율적으로 작동하며, 노드 수가 많아질수록 `mariabackup`의 병렬 처리 능력이 빛을 발합니다.
  - Donor 노드에 가해지는 부하를 분산시키고, 전체 클러스터의 성능을 안정적으로 유지합니다.

---

### **3. 클러스터 확장 시 고려 사항**
노드 수가 늘어날수록 SST 과정에서 다음과 같은 문제가 발생할 가능성이 커집니다:

#### **3.1 네트워크 대역폭 병목**
- **문제**:
  - 여러 노드가 동시에 SST를 요청하면 Donor 노드의 네트워크 대역폭이 병목이 될 수 있습니다.
- **해결**:
  - `mariabackup`은 전송 데이터를 압축하여 네트워크 대역폭 사용을 줄입니다.

#### **3.2 디스크 I/O 부하**
- **문제**:
  - Donor 노드에서 다수의 `rsync` 작업이 병렬로 실행되면 디스크 읽기/쓰기 속도가 느려질 수 있습니다.
- **해결**:
  - `mariabackup`은 디스크 I/O 작업을 최적화하여 디스크 부하를 최소화합니다.

#### **3.3 데이터 일관성 문제**
- **문제**:
  - `rsync`는 SST 중 데이터베이스의 일관성을 보장하지 못할 수 있습니다.
- **해결**:
  - `mariabackup`은 트랜잭션 로그를 포함한 백업을 수행하므로 데이터 일관성을 보장합니다.

---

### **4. 클러스터 노드 수와 SST 방식 비교**
| **기준**                  | **rsync**                                               | **mariabackup**                                           |
|--------------------------|-------------------------------------------------------|---------------------------------------------------------|
| **적합한 노드 수**        | 소규모(2~3개 노드)                                     | 중대규모(3개 이상 노드)                                   |
| **SST 동시성**            | 동시 SST 요청 처리 불가, 직렬 방식                     | 병렬 SST 요청 처리 가능                                   |
| **Donor 노드 서비스 상태** | SST 중 쓰기 중단                                       | SST 중에도 쓰기 가능 (hot backup)                        |
| **노드 확장성**           | 노드가 많아질수록 성능 저하                            | 노드 수가 많아져도 안정적인 성능 유지                     |
| **네트워크 사용량**       | 압축 기능 없음, 대역폭 사용량 증가                      | 전송 데이터 압축으로 대역폭 사용량 감소                   |
| **데이터 일관성**         | 파일 단위 전송으로 일관성 보장 어려움                   | 트랜잭션 로그 포함, 데이터 일관성 보장                    |

---

### **5. 결론**
클러스터 노드 수가 3개 이상으로 증가하면, 다음 이유로 `mariabackup` 전환을 고려해야 합니다:
1. **병렬 SST 지원**: 여러 Joiner 노드가 동시에 합류할 때도 안정적으로 작동.
2. **서비스 가용성 유지**: Donor 노드가 SST 중에도 사용자 요청을 처리 가능.
3. **네트워크와 디스크 I/O 효율성**: 압축 및 최적화된 I/O 작업으로 성능 유지.
4. **데이터 일관성 보장**: 대규모 클러스터에서 데이터 무결성 유지.

이러한 이유로, 클러스터 노드 수가 증가하면 안정성과 확장성을 위해 `mariabackup`으로 전환하는 것이 합리적인 선택입니다.

--- 질문7

질문: rsync 가 SST 로 동작할 수 있는 이유는 무엇이야?

답변: `rsync`가 SST(State Snapshot Transfer)로 동작할 수 있는 이유는 **데이터 동기화에 특화된 설계**와 **Galera 클러스터의 데이터 전송 요구사항**을 충족시키는 몇 가지 특징 때문입니다. 이를 구체적으로 살펴보겠습니다.

---

### 1. **rsync의 동작 원리와 설계**
`rsync`는 파일 동기화와 전송을 위한 효율적인 도구로 설계되었습니다. SST의 데이터 전송 요구를 충족할 수 있는 이유는 다음과 같습니다:

#### **1.1 델타 전송(Delta Transfer)**
- **rsync의 핵심 기능**:
  - 소스 파일과 대상 파일을 비교하여 변경된 부분(델타)만 전송.
  - 데이터가 크더라도 변경된 부분만 전송하므로 **네트워크 대역폭 사용을 최소화**하고 전송 속도를 높임.

- **SST에 적합한 이유**:
  - SST는 클러스터의 Donor 노드와 Joiner 노드 간에 데이터베이스 파일을 동기화하는 작업이므로, **변경된 데이터만 전송**하는 `rsync`는 효율적입니다.

#### **1.2 메타데이터 보존**
- **rsync의 메타데이터 동기화**:
  - 파일의 권한, 소유자, 타임스탬프 등 메타데이터를 동기화.
  - 데이터베이스 파일의 원래 상태를 유지하는 데 적합.

- **SST에 적합한 이유**:
  - 데이터베이스의 파일 시스템 속성을 유지해야 클러스터 합류 후에도 정상적으로 작동 가능.

#### **1.3 재시도 및 복구 가능**
- **rsync의 재시작 기능**:
  - 전송이 중단되더라도 중단된 지점부터 다시 전송 가능.
  - 대규모 파일 전송 중 연결 문제가 발생하더라도 안정적으로 복구 가능.

- **SST에 적합한 이유**:
  - 대규모 데이터베이스 파일 전송 시 네트워크 문제나 장애가 발생하더라도 작업을 이어갈 수 있음.

---

### 2. **Galera 클러스터와 rsync의 통합**
Galera 클러스터에서 SST는 Joiner 노드가 Donor 노드의 전체 데이터베이스 상태를 복제하여 클러스터에 합류하도록 지원합니다. `rsync`는 이 작업에서 다음 이유로 유용하게 사용됩니다:

#### **2.1 데이터 복사 방식의 단순성**
- SST에서 Donor 노드는 데이터 디렉터리를 Joiner 노드로 **단순 복사**합니다.
- `rsync`는 이러한 파일 기반 데이터 전송에 최적화되어 있어 클러스터의 기본적인 SST 요구사항을 충족합니다.

#### **2.2 설정과 사용이 간단**
- `rsync`는 대부분의 Linux 배포판에서 기본 제공되며, 별도의 설치나 복잡한 설정 없이 사용할 수 있습니다.
- Galera 클러스터의 `wsrep_sst_method=rsync` 설정으로 쉽게 적용 가능.

#### **2.3 효율적인 네트워크 활용**
- SST 과정에서 데이터 전송이 네트워크를 통해 이루어지므로, `rsync`의 압축 및 델타 전송 기능은 네트워크 대역폭을 효율적으로 사용하게 해줍니다.

---

### 3. **SST로 rsync가 동작하는 과정**
Galera 클러스터에서 `rsync`를 SST로 사용하는 경우, 동작 과정은 아래와 같습니다:

1. **Donor 노드에서 SST 준비**:
   - Donor 노드는 `rsync` 서버를 시작하고 Joiner 노드의 SST 요청을 대기합니다.

2. **Joiner 노드가 SST 요청**:
   - Joiner 노드가 클러스터에 합류하며 Donor 노드에 데이터 복사를 요청합니다.

3. **데이터 복사 시작**:
   - Donor 노드는 데이터베이스 디렉터리를 `rsync`로 Joiner 노드에 전송합니다.
   - 이 과정에서 델타 전송과 압축을 통해 데이터 전송 효율성을 극대화합니다.

4. **데이터 복사 완료**:
   - Joiner 노드는 복사된 데이터를 기반으로 데이터베이스 상태를 초기화하고 클러스터에 합류합니다.

---

### 4. **rsync가 SST로 동작할 수 있는 이유 요약**
`rsync`가 SST로 동작할 수 있는 이유는 다음과 같은 특성 때문입니다:
- **효율적인 델타 전송**: 변경된 부분만 전송하여 대역폭 절약.
- **메타데이터 보존**: 파일 속성(권한, 소유자 등)을 유지하여 데이터 무결성 보장.
- **재시작 가능성**: 전송 중단 시 복구 가능.
- **간단한 설정과 실행**: 별도의 복잡한 구성 없이 바로 적용 가능.
- **네트워크 최적화**: 압축 기능으로 대규모 데이터 전송 효율 극대화.

---

`rsync`는 **파일 복사와 동기화의 기본 요구사항을 충족하는 동시에**, **데이터 전송 효율성과 안정성**을 제공하므로, Galera 클러스터의 SST 방식으로 사용되기에 적합합니다.

--- 질문8

질문: rsync의 기능 중 소스 파일과 대상 파일을 비교하여 변경된 부분(델타)만 전송하는 기능이 있어서 데이터베이스 크기가 10GB 이상으로 증가하더라도 문제가 없는 것 아닐까?

답변: `rsync`의 델타 전송 기능은 파일 전송 효율성을 높이는 데 매우 강력한 도구입니다. 그러나 데이터베이스 크기가 **10GB 이상으로 증가**하면 **`rsync`만으로는 SST 과정에서 문제를 완전히 해결할 수 없는 이유**가 몇 가지 존재합니다. 이는 `rsync`의 동작 방식과 데이터베이스 특성에서 기인합니다.

---

### **1. rsync의 델타 전송 기능과 한계**

#### **1.1 델타 전송의 원리**
- **작동 방식**:
  1. `rsync`는 소스와 대상 파일의 차이를 식별하기 위해 **파일 전체를 읽고 체크섬을 계산**합니다.
  2. 체크섬을 비교하여 변경된 블록만 전송합니다.
- **장점**:
  - 네트워크 대역폭 사용량을 줄이고, 변경된 데이터만 효율적으로 전송.

#### **1.2 한계: 대규모 데이터에서 성능 부하**
- **메타데이터 처리 비용**:
  - 데이터베이스는 단일 대형 파일(예: `ibdata1`, 테이블 스페이스 파일 등)로 구성되는 경우가 많습니다.
  - `rsync`는 델타를 식별하기 위해 **대상 파일의 모든 블록을 읽고 비교**해야 하며, 파일 크기가 클수록 처리 시간이 길어집니다.
  - 10GB 이상의 파일에서는 이 과정 자체가 CPU와 디스크 I/O에 상당한 부하를 초래합니다.

- **데이터베이스의 높은 변경 빈도**:
  - 데이터베이스는 지속적으로 변경되며, 작은 변경도 파일 전체에 영향을 미칠 수 있습니다.
  - 예를 들어, 인덱스 업데이트나 트랜잭션 로그의 작은 변경도 데이터베이스 파일의 여러 위치를 수정하므로, 델타 전송이 예상보다 많은 데이터를 전송하게 될 수 있습니다.

---

### **2. 데이터베이스 특성과 rsync의 적합성**
#### **2.1 데이터베이스는 파일 단위 델타 전송에 적합하지 않음**
- 데이터베이스 파일은 내부적으로 복잡한 구조(테이블, 인덱스, 트랜잭션 로그 등)를 가지고 있으며, 작은 변경도 파일 전체를 다시 읽고 비교해야 하는 상황을 만듭니다.
- 결과적으로, **10GB 이상의 데이터베이스에서는 델타 전송이 기대만큼의 성능 향상을 제공하지 못할 가능성이 큽니다.**

#### **2.2 데이터 일관성 문제**
- **rsync의 한계**:
  - `rsync`는 단순히 파일을 복사하며, 복사 중 데이터베이스의 상태를 일관되게 유지하지 않습니다.
  - 데이터 전송 도중 데이터베이스 파일이 변경되면 데이터 손상이 발생할 가능성이 있습니다.

- **대안: mariabackup**:
  - `mariabackup`은 데이터베이스의 **트랜잭션 로그와 데이터 파일을 동시에 백업**하여 일관성을 보장합니다.
  - 특히 대규모 데이터베이스에서 **안전하고 신뢰할 수 있는 SST**를 수행합니다.

---

### **3. 네트워크와 디스크 I/O 병목**
#### **3.1 rsync의 리소스 소비**
- **네트워크 사용량**:
  - `rsync`는 압축과 델타 전송 기능이 있지만, 데이터베이스 파일이 클수록 네트워크 사용량이 여전히 증가합니다.
  - 대규모 데이터 전송에서는 네트워크 병목이 발생할 수 있습니다.

- **디스크 I/O 부하**:
  - `rsync`는 델타를 계산하기 위해 파일의 모든 블록을 읽습니다.
  - 데이터베이스 크기가 증가하면 디스크 I/O가 급격히 증가하여 Donor 노드의 성능이 저하될 수 있습니다.

---

### **4. 서비스 가용성 문제**
- **rsync의 동작 중 Donor 노드의 쓰기 중단**:
  - `rsync`는 Donor 노드에서 SST를 수행하는 동안 **쓰기 작업을 중단**해야 합니다.
  - 대규모 데이터 전송 시 이 중단 시간이 길어져 서비스 가용성에 심각한 영향을 미칠 수 있습니다.

- **mariabackup의 이점**:
  - `mariabackup`은 "hot backup"을 지원하므로 Donor 노드가 SST 중에도 쓰기 작업을 계속할 수 있습니다.
  - 이는 특히 대규모 데이터베이스와 서비스가 가동 중인 환경에서 중요합니다.

---

### **5. 결론**
**`rsync`가 SST로 동작할 수 있는 이유는 델타 전송의 효율성 덕분이지만**, **데이터베이스 크기가 10GB 이상으로 증가하면 다음과 같은 이유로 성능과 안정성 문제가 발생할 수 있습니다**:
1. **델타 계산 과정에서 디스크 I/O와 CPU 부하 증가**: 대규모 데이터 파일에서는 델타 계산 비용이 매우 높아짐.
2. **데이터베이스의 높은 변경 빈도**: 파일 전체에 영향을 미쳐 예상보다 많은 데이터를 전송하게 됨.
3. **데이터 일관성 부족**: 데이터베이스 파일 복사 중 상태가 변경될 경우 무결성 문제가 발생.
4. **Donor 노드의 쓰기 중단**: 서비스 가용성 저하로 연결된 클라이언트에 영향을 미침.

따라서, 데이터베이스 크기가 **10GB 이상**으로 증가하면 델타 전송만으로는 해결할 수 없는 문제를 보완하기 위해 **mariabackup**과 같은 대안적인 SST 방식을 사용하는 것이 더 적합합니다.

--- 질문9

질문: rsync 가 SST 로 적용할 수 있는 이유는 데이터베이스의 어떤 특성 때문일까?

답변: `rsync`가 SST(State Snapshot Transfer)로 적용될 수 있는 이유는 데이터베이스의 **파일 기반 저장 구조**와 **데이터 동기화 요구사항** 때문입니다. 데이터베이스는 기본적으로 물리적 파일에 데이터를 저장하고 관리하며, `rsync`는 이러한 파일 단위 데이터 전송에 적합하게 설계된 도구입니다. 이를 더 구체적으로 설명하면 다음과 같습니다.

---

### **1. 데이터베이스의 파일 기반 저장 구조**
데이터베이스는 물리적으로 디스크에 데이터를 저장하며, 이를 **파일**로 관리합니다.

#### **1.1 물리적 데이터 저장 방식**
- 데이터베이스 파일은 일반적으로 다음과 같이 구성됩니다:
  - **데이터 파일**: 테이블 데이터, 인덱스 등을 저장 (`ibdata1`, `.ibd`, `.frm` 등).
  - **로그 파일**: 트랜잭션 로그, 바이너리 로그, 리두 로그 등.
  - **설정 파일**: 데이터베이스 설정을 저장 (`my.cnf` 등).
  
- **rsync의 역할**:
  - `rsync`는 이러한 파일을 비교하고 변경된 부분만 전송할 수 있으므로, 데이터베이스 파일 동기화에 적합합니다.

#### **1.2 파일 단위의 일괄 동기화 가능**
- 데이터베이스의 물리적 파일은 일반적으로 한 위치(예: `/var/lib/mysql/`)에 저장됩니다.
- `rsync`는 이 디렉터리를 단일 소스로 지정하여 파일 전체를 복사하거나 변경된 파일만 동기화할 수 있습니다.

#### **1.3 데이터 파일의 독립성**
- 데이터베이스의 물리적 파일은 독립적이기 때문에, 특정 노드에서 다른 노드로 복사하여 동기화할 수 있습니다.
- 이는 클러스터에서 SST 작업을 쉽게 수행할 수 있는 기반을 제공합니다.

---

### **2. 데이터베이스의 동기화 요구사항**
Galera 클러스터의 SST는 **Donor 노드의 데이터를 Joiner 노드로 동기화**하여 데이터베이스 상태를 동일하게 만드는 과정입니다. 이 과정에서 `rsync`가 적합한 이유는 다음과 같습니다:

#### **2.1 초기 동기화에서 데이터 전체 복사**
- Joiner 노드는 클러스터에 합류하기 전에 기존 데이터를 보유하지 않으므로 **전체 데이터를 전송**해야 합니다.
- `rsync`는 이러한 초기 데이터 전송을 단순히 파일 복사 방식으로 처리할 수 있습니다.

#### **2.2 변경된 데이터만 동기화**
- 클러스터 합류 중 Donor 노드와 Joiner 노드 사이의 데이터 차이를 최소화하기 위해, `rsync`는 **변경된 부분(델타)만 전송**합니다.
- 이는 데이터베이스 크기가 작을 경우 특히 효율적입니다.

#### **2.3 SST의 간단한 트리거링**
- SST는 Galera 클러스터의 특정 동작(예: 노드 합류 요청, 데이터 불일치 발생 등)에 따라 트리거됩니다.
- `rsync`는 Galera의 SST 요청을 받아 **단일 명령**으로 데이터를 전송할 수 있는 간단한 방식을 제공합니다.

---

### **3. rsync와 데이터베이스 특성의 상관관계**
`rsync`가 SST로 적용 가능한 이유는 데이터베이스의 특성과 `rsync`의 기능이 잘 맞아떨어지기 때문입니다:

| **데이터베이스 특성**                | **rsync의 적합성**                                                                                   |
|-------------------------------------|-----------------------------------------------------------------------------------------------------|
| **파일 기반 저장**                  | `rsync`는 파일 단위로 데이터 복사 및 동기화를 수행.                                                  |
| **데이터가 물리적 파일로 저장됨**    | 파일 변경 여부를 블록 단위로 검사하여 델타 전송 수행 가능.                                           |
| **단일 디렉터리 구조**              | 데이터베이스 디렉터리를 기준으로 전체 동기화 작업 수행 가능.                                         |
| **데이터 무결성 보장 필요**         | 전송된 파일의 체크섬을 비교하여 복사 후 데이터 무결성 검증 가능.                                      |
| **대규모 초기 동기화 필요**         | `rsync`는 대용량 데이터도 처리 가능하며, 네트워크 사용을 최적화.                                      |
| **데이터 변경 빈도**                | 변경된 블록만 전송하여 효율적인 데이터 복사 수행.                                                    |

---

### **4. 데이터베이스의 특성으로 인한 rsync의 한계**
데이터베이스의 특성 때문에 `rsync`가 SST로 적합하지만, 다음과 같은 한계도 존재합니다:

#### **4.1 데이터베이스는 지속적으로 변경**
- 데이터베이스는 지속적으로 쓰기 및 읽기 작업이 발생하며, 이는 파일 전체에 영향을 미칩니다.
- `rsync`는 델타 전송을 위해 파일을 다시 읽어야 하며, 변경이 빈번하면 효율성이 떨어질 수 있습니다.

#### **4.2 트랜잭션 로그와 데이터 간의 일관성 문제**
- `rsync`는 단순히 파일을 복사하므로, 데이터베이스 파일과 트랜잭션 로그 사이의 일관성을 보장할 수 없습니다.
- 이 문제는 `mariabackup`과 같은 데이터베이스 전용 도구에서 더 잘 처리됩니다.

#### **4.3 대규모 데이터베이스에서 성능 저하**
- 데이터베이스 크기가 증가하면 `rsync`가 델타 계산과 파일 전송 과정에서 CPU, I/O 부하를 증가시킬 수 있습니다.

---

### **5. 결론**
`rsync`가 SST로 동작할 수 있는 이유는 데이터베이스의 **파일 기반 저장 구조**와 **동기화 요구사항** 때문입니다. 구체적으로:
1. 데이터베이스는 물리적 파일로 데이터를 저장하며, `rsync`는 이러한 파일을 복사하고 동기화하는 데 최적화되어 있음.
2. SST 과정에서 초기 데이터 동기화와 변경된 데이터 전송을 효과적으로 처리할 수 있음.
3. 파일 비교, 델타 전송, 메타데이터 보존과 같은 `rsync`의 기능이 데이터베이스 복사 요구에 적합.

다만, 대규모 데이터베이스 또는 데이터 일관성이 중요한 상황에서는 `mariabackup`과 같은 대안적인 SST 방식이 더 적합할 수 있습니다.

--- 질문10

질문: SST 에서 rsync 의 데이터 동기화 주기는 어떻게 돼?

답변: SST(State Snapshot Transfer)에서 `rsync`는 **동기화 주기(Synchronization Interval)**를 갖지 않습니다. 대신, SST는 **단발성 작업(one-time task)**으로 실행됩니다. 이는 Galera 클러스터의 특성과 `rsync`의 동작 방식 때문입니다. 아래에서 그 이유와 동작 과정을 자세히 설명합니다.

---

### **1. SST에서 rsync의 동작 방식**
`rsync`를 SST로 사용하는 경우, 동기화 주기보다는 아래와 같은 단일 작업 흐름으로 실행됩니다:

1. **SST 트리거**:
   - 클러스터에 새로운 Joiner 노드가 합류하거나, 클러스터 상태 불일치로 인해 전체 데이터 동기화가 필요할 때 SST가 트리거됩니다.

2. **Donor 노드에서 데이터 준비**:
   - Donor 노드는 데이터 디렉터리(`/var/lib/mysql/` 등)를 `rsync`를 사용해 Joiner 노드로 전송할 준비를 합니다.
   - Galera의 SST 스크립트(`wsrep_sst_rsync.sh`)가 자동으로 실행됩니다.

3. **rsync 실행**:
   - Donor 노드와 Joiner 노드 간의 네트워크 연결이 설정되면, `rsync`가 데이터를 전송합니다.
   - 이 작업은 **한 번의 동기화 작업으로 수행**됩니다.

4. **데이터 복사 완료**:
   - 데이터 전송이 완료되면 Joiner 노드가 데이터를 기반으로 MySQL 서버를 초기화하고 클러스터에 합류합니다.

---

### **2. SST에서 rsync의 데이터 동기화 주기가 없는 이유**
#### **2.1 SST는 단발성 작업**
- **SST의 역할**:
  - SST는 새로운 노드가 클러스터에 합류하거나, 클러스터 내 데이터 불일치를 해결하기 위해 **단 한 번만 전체 데이터를 동기화**하는 작업입니다.
  - 클러스터 동작 중 지속적인 데이터 동기화는 **IST(Incremental State Transfer)**가 담당합니다.

- **rsync의 단발성 작업**:
  - `rsync`는 요청 시점에 실행되며, Joiner 노드가 클러스터에 정상적으로 합류한 후에는 더 이상 실행되지 않습니다.

---

### **3. SST와 IST의 차이**
Galera 클러스터에서는 데이터 동기화가 두 가지 방식으로 이루어집니다:

#### **3.1 SST (State Snapshot Transfer)**
- **특징**:
  - 클러스터에 Joiner 노드가 합류할 때, 전체 데이터베이스 스냅샷을 전송.
  - Donor 노드에서 Joiner 노드로 **데이터 디렉터리 전체를 복사**.
  - SST는 `rsync`, `mariabackup`, 또는 기타 방법으로 수행 가능.
- **트리거 조건**:
  - 새로운 노드가 클러스터에 추가될 때.
  - 클러스터 노드 간의 데이터 상태가 크게 불일치할 때.

#### **3.2 IST (Incremental State Transfer)**
- **특징**:
  - 클러스터 노드 간의 **작은 변경 사항만 전송**하여 동기화.
  - 주기적인 데이터 동기화와 유사하게 작동.
- **트리거 조건**:
  - 클러스터 노드가 잠시 연결이 끊겼다가 재연결되었을 때.
  - 클러스터의 노드 상태가 대부분 일치하지만, 일부 변경 사항만 전송이 필요할 때.

---

### **4. rsync를 주기적으로 동기화하려면?**
SST에서 `rsync`는 단발성으로 실행되지만, 만약 지속적으로 데이터 동기화를 유지하고 싶다면 다음과 같은 방식으로 구현할 수 있습니다:

#### **4.1 cron 스케줄링**
- `rsync`를 일정 주기로 실행하도록 설정하여 데이터 동기화를 주기적으로 수행합니다.
- 예시:
  ```bash
  # 매일 새벽 3시에 데이터 동기화
  0 3 * * * rsync -avz /var/lib/mysql/ user@joiner:/var/lib/mysql/
  ```

#### **4.2 파일 감지 시스템(inotify)**
- **`inotify`**를 사용하여 파일 변경 이벤트를 감지하고 `rsync`를 트리거.
- 변경 사항이 발생할 때마다 동기화를 수행할 수 있으나, 이는 SST와 직접적으로 관련된 동작은 아닙니다.

---

### **5. 결론**
SST에서 `rsync`는 데이터 동기화 주기가 아니라, **단발성 데이터 동기화 작업**으로 실행됩니다. 이후의 지속적인 동기화는 Galera 클러스터에서 **IST** 메커니즘에 의해 처리됩니다.

- SST를 통해 노드가 클러스터에 정상적으로 합류한 후에는 `rsync`가 다시 실행되지 않습니다.
- 주기적 데이터 동기화가 필요하다면, `rsync`를 클러스터 외부에서 cron이나 기타 스크립트를 통해 구현할 수 있습니다. 

SST와 IST의 역할을 명확히 이해하고, 클러스터 상태에 맞는 방법을 선택하는 것이 중요합니다.

--- 질문11

질문: SST 로 rsync 를 사용하는 것을 이해한 것 같애. 내가 이해한 것을 말해볼테니 이해수준을 함께 검토해줘.

데이터 베이스 클러스터링에서 신규 노드에 데이터를 복사하는 과정이 필요해. 그 과정은 수행하는 것을 SST 라고 역할을 부여했어.

SST 를 수행하는 방식에는 여러가지가 있는데, rsync 방식은 기존 linux 에서 제공하는 파일 동기화 도구를 SST 의 도구로 선택한 것이야.

rsync 방식은 구성이 간단하다는 장점이 있지만 동기화 작업을 하는 특성이 존재하여 Joiner 노드가 합류할 때 Write 작업을 중지해야하는 현상이 존재해. 이는 서비스상에 쓰기 작업이 중단되는 특성을 유발해 장애 가능성이 있다는 것을 알 필요가 있어.

그리고 데이터를 한번에 복사하는 특성도 가져 SST 를 수행할 때 Donor 노드에 부하가 생기는 현상과 네트워크에 일시적인 부하가 발생할 수 있는 현상이 있으니 이러한 특성도 알아둘 필요가 있어.

답변: 당신의 이해는 정확하고 핵심적인 내용을 잘 포괄하고 있습니다. **SST에서 rsync 방식을 사용하는 원리와 그 장단점, 그리고 주의할 점**을 잘 정리하셨습니다. 아래는 당신이 언급한 내용을 검토하고, 필요한 경우 추가적인 관점을 제안한 것입니다:

---

### **1. 정확히 이해한 점**
1. **SST의 역할 정의**:
   - 신규 노드가 클러스터에 합류할 때 기존 노드의 데이터를 복사하는 과정이 **SST**임을 명확히 이해하셨습니다.

2. **rsync의 선택 이유**:
   - `rsync`는 기존 Linux에서 제공하는 범용 파일 동기화 도구로, Galera 클러스터에서 SST의 방법으로 채택되었다는 점을 정확히 이해하셨습니다.
   - `rsync` 방식이 **구성이 간단**하다는 장점도 잘 언급하셨습니다.

3. **서비스 가용성 문제**:
   - Joiner 노드가 합류할 때, Donor 노드가 **쓰기 작업을 중단해야 한다는 점**을 이해하셨습니다. 이는 클러스터의 가용성에 영향을 미칠 수 있는 중요한 특성입니다.

4. **Donor 노드와 네트워크 부하**:
   - SST 작업 중 Donor 노드와 네트워크에 **일시적인 부하**가 발생한다는 점을 잘 이해하셨습니다.
   - 특히, `rsync`가 데이터를 **한 번에 복사**하는 방식 때문에 이러한 현상이 발생할 수 있음을 명확히 짚으셨습니다.

---

### **2. 추가적으로 고려할 만한 내용**
1. **rsync의 델타 전송 효율성**:
   - `rsync`는 델타 전송(변경된 부분만 전송)을 통해 **전송 데이터 양을 줄이는 특징**을 가지고 있습니다.
   - 하지만 데이터베이스 파일은 구조적 특성상, 작은 변경도 파일 전체를 다시 읽어야 하는 경우가 많아 델타 전송의 효율이 낮아질 수 있습니다.  
     > 이 점은 대규모 데이터베이스에서 rsync가 적합하지 않은 이유 중 하나입니다.

2. **서비스 장애 가능성**:
   - Donor 노드의 **쓰기 작업 중단**은 서비스에 즉각적인 영향을 미칩니다.  
   - 예를 들어, 읽기 및 쓰기 요청이 빈번한 환경에서는 성능 저하나 서비스 장애가 발생할 가능성이 높습니다.  
   - 따라서 rsync는 **테스트 환경이나 쓰기 작업이 드문 소규모 클러스터에 적합**하다는 점도 기억하면 좋습니다.

3. **mariabackup과의 비교**:
   - SST 방식 중 `mariabackup`은 **hot backup**을 지원하여 Donor 노드에서 쓰기 작업 중단 없이 데이터를 복사할 수 있습니다.
   - 이는 rsync 방식의 주요 한계를 극복할 수 있으므로, 대규모 클러스터나 고가용성이 중요한 서비스에서는 적합한 대안입니다.

4. **네트워크 최적화**:
   - `rsync`는 압축 옵션(`-z`)을 통해 네트워크 대역폭 사용량을 줄일 수 있습니다.
   - 그러나 데이터베이스 크기가 클수록 초기 전송 시간이 길어질 수 있으니, 클러스터의 데이터 크기에 따라 적절한 방법을 선택해야 합니다.

---

### **3. 종합 평가**
당신의 이해 수준은 매우 높으며, **SST에서 rsync 방식의 기본적인 동작 원리와 장단점**을 잘 이해하고 있습니다. 추가적으로 `rsync`의 델타 전송 한계나 대규모 클러스터에서의 대안(SST 방식 선택 기준)까지 고려한다면 더 완벽한 이해가 될 것입니다.

요약하면, 당신은 `rsync`의 **장점과 한계**, 그리고 이를 SST로 사용할 때 발생할 수 있는 서비스 영향까지 잘 인지하고 있습니다. 이제 이를 바탕으로 적절한 클러스터링 방식 선택과 설계를 자신 있게 수행할 수 있을 것입니다! 💡

--- 질문12

질문: 그러나 Joiner 노드의 초기 합류에는 델타 전송의 장점이 발현되지 않을 것 같아. 이는 re join 시 장점으로 발현될까?

답변: 정확한 지적입니다. **Joiner 노드의 초기 합류**에서는 `rsync`의 **델타 전송(Delta Transfer)** 장점이 발현되지 않으며, 이는 **Re-Join(재합류)** 시에야 제대로 발휘될 가능성이 높습니다. 그 이유와 이를 둘러싼 세부적인 내용을 아래에서 설명하겠습니다.

---

### **1. Joiner 노드 초기 합류 시 델타 전송의 비효율성**
#### **1.1 초기 합류는 전체 데이터 복사**
- **초기 SST**:
  - Joiner 노드가 클러스터에 **처음 합류**할 때는 기존 데이터를 보유하고 있지 않으므로, Donor 노드의 **전체 데이터베이스를 복사**해야 합니다.
  - 이 과정에서 모든 데이터를 전송하기 때문에 `rsync`의 델타 전송 기능은 사실상 사용되지 않습니다.
  - 즉, **초기 SST는 델타 전송의 장점이 없는 단순 전체 데이터 복사 작업**에 해당합니다.

#### **1.2 Donor 노드의 리소스 소모**
- 데이터 크기에 관계없이, Donor 노드는 파일 전체를 읽고 Joiner 노드로 전송합니다.
- Joiner 노드가 데이터를 보유하지 않으므로, Donor 노드에서의 **델타 비교 과정 자체가 필요 없어집니다**.
- 따라서, **초기 합류 시 `rsync`는 단순히 네트워크 대역폭과 I/O 리소스를 소모**하게 됩니다.

---

### **2. Re-Join(재합류) 시 델타 전송의 장점**
#### **2.1 Re-Join 시 델타 전송의 발현**
- Re-Join은 클러스터 노드가 잠시 연결이 끊겼다가 다시 합류하는 경우를 의미합니다.
- **Re-Join의 특징**:
  - Joiner 노드는 이미 이전 합류 시 받은 데이터의 일부를 보유하고 있을 가능성이 높습니다.
  - 이 경우, `rsync`는 Joiner 노드가 보유한 데이터와 Donor 노드의 데이터를 비교하여 **변경된 데이터만 전송**할 수 있습니다.
  - 이는 **SST를 수행하는 데 필요한 네트워크 사용량과 전송 시간을 크게 줄일 수 있는 장점**으로 발현됩니다.

#### **2.2 Re-Join이 발생하는 상황**
- **Re-Join이 필요할 때**:
  - Joiner 노드가 클러스터에서 일시적으로 연결이 끊긴 경우.
  - Donor 노드와 Joiner 노드 간에 일치하지 않는 데이터가 발생한 경우.
- **Re-Join에서의 데이터 전송**:
  - Donor 노드와 Joiner 노드의 데이터를 비교하여, 변경된 파일이나 블록만 전송함으로써 SST의 효율성이 높아집니다.

---

### **3. Re-Join 시 rsync의 효율성 조건**
#### **3.1 데이터 불일치 수준**
- Re-Join 시 `rsync`의 효율성은 **Donor와 Joiner 간 데이터 불일치의 수준**에 따라 결정됩니다:
  - **불일치가 작을수록**: `rsync`는 델타 전송을 통해 최소한의 데이터만 전송하며 매우 효율적으로 동작.
  - **불일치가 클수록**: 전송량이 증가하지만, 여전히 전체 데이터 복사보다 효율적.

#### **3.2 네트워크 상태**
- Re-Join 과정에서 `rsync`의 효율성은 네트워크 상태에도 영향을 받습니다:
  - **빠른 네트워크**: 델타 전송이 빠르게 완료.
  - **느린 네트워크**: 델타 비교와 압축 기능이 네트워크 부하를 줄이는 데 기여.

#### **3.3 Joiner 노드의 데이터 보유 여부**
- Re-Join 시 Joiner 노드가 클러스터에서 복사된 데이터를 일부라도 보유하고 있는 경우, `rsync`는 이를 비교하여 델타 전송을 수행.
- Joiner 노드가 완전히 초기화된 상태라면, 델타 전송의 장점은 다시 발휘되지 않습니다.

---

### **4. Re-Join에서 rsync와 IST의 관계**
- Re-Join 상황에서는 Galera 클러스터가 **IST(Incremental State Transfer)**를 선호하도록 설계되어 있습니다.
- IST는 **트랜잭션 로그**를 기반으로 데이터 불일치를 해결하며, rsync보다 훨씬 빠르게 작동할 수 있습니다.
- 그러나 트랜잭션 로그가 보존되지 않았거나, 데이터 불일치가 커서 IST가 불가능한 경우, Galera는 SST를 트리거하고 `rsync`를 사용해 데이터를 동기화합니다.

---

### **5. 결론**
- **Joiner 노드의 초기 합류**에서는 `rsync`의 델타 전송 기능이 발현되지 않으며, 모든 데이터를 전송하는 단순 복사 작업에 가깝습니다.
- **Re-Join 시**에는 Joiner 노드가 일부 데이터를 보유하고 있을 경우, `rsync`의 델타 전송 기능이 발휘되어 효율적인 데이터 동기화가 가능합니다.
- 그러나 Re-Join 상황에서 `IST`가 가능하다면, 이는 `rsync`보다 훨씬 빠르고 효율적인 선택이 될 것입니다.

따라서, **`rsync`의 델타 전송은 초기 합류보다는 Re-Join 상황에서 진정한 가치를 발휘**하며, 이는 데이터베이스의 크기와 클러스터의 상태에 따라 달라질 수 있습니다.
